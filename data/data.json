handleData([{"name":"First question","instruction":"Нажми на слово CLICK.","learning":false,"code":"void Main()\n{\n\tConsole.WriteLine(\"Enter your name: \");\n\tvar {{CLICK}} = Console.ReadLine();\n\tConsole.WriteLine(\"Hello, \" + {{CLICK}});\n}","bugs":{"CLICK":{"type":"naming","replace":"name","description":"Молодец, чё"}}},{"name":"BubbleSort","instruction":"Найдите все ошибки в реализации сортировки пузырьком.","learning":false,"code":"int temp; // временная переменная для обмена элементов местами\n// Сортировка массива пузырьком\nfor (int i = {{1}}; i < size-1; i++) {\n\tfor (int j = 0; j < {{size-i}}; j++) {\n\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t// меняем элементы местами\n\t\t\ttemp = arr[j];\n\t\t\tarr[j] = {{temp}};\n\t\t\tarr[j + 1] = temp;\n\t\t}\n\t}\n}","bugs":{"1":{"type":"sort","replace":"0","description":"Не забываем, что индексирование элементов в массиве начинается с нуля."},"size-i":{"type":"sort","replace":"size-i-1","description":"Мы обязаны не забыть вычесть единицу, чтобы не вылезти за пределы массива."},"temp":{"type":"sort","replace":"arr[j+1]","description":"Соблюдайте правильную логику переставления элементов."}}},{"name":"SelectSort","instruction":"Найдите все ошибки в реализации сортировки выбором.","learning":false,"code":"void selectSort(int* arr, int size)\n{\n\tint tmp, i, j, pos;\n\tfor(i = 0; i < size; ++i)\n\t{\n\t\tposition = {{0}};\n\t\ttmp = arr{{[i-1]}};\n\t\tfor(j = i + 1; j < size; ++j)\n\t\t{\n\t\t\tif (arr[j] < tmp)\n\t\t\t{\n\t\t\t\tpos = j;\n\t\t\t\ttmp = arr[j];\n\t\t\t}\n\t\t}\n\t\tarr[pos] = {{tmp}};\n\t\tarr[i] = {{arr[i]}};\n\t}\n}","bugs":{"0":{"type":"sort","replace":"i","description":"Позиция на каждой итерации увеличивается, что соответствует счетчику i."},"[i-1]":{"type":"sort","replace":"[i]","description":"Очевидно, временным элементом будет являться текущий элемент массива, а не предыдущий. Темболее, на нулевой итерации мы получим ошибку, пытаясь взять -1 элемент массива."},"arr[i]":{"type":"sort","replace":"tmp","description":"В очередной итерации мы должны записать наименьший элемент."},"tmp":{"type":"sort","replace":"arr[i]","description":"Ставим на место наименьшего элемента текущий элемент."}}},{"name": "Stack","instruction": "Исправьте описание интерфейса стека","learning": false,"code": "template <typename T>\n{{struct}} Stack\n{\nprivate:\n\tT *stackPtr;\t\t// указатель на стек\n\tconst int size;\t\t// максимальное количество элементов в стеке\n\tint indexOfLast;\t\t// индекс последнего элемента, добавленного в стек\npublic:\n\tStack(int = 10);\t\t// по умолчанию размер стека равен 10 элементам\n\n\tinline void push(const T & );\t\t// поместить элемент в вершину стека\n \tinline {{int}} pop();\t\t// удалить элемент из вершины стека и вернуть его\n\tinline void printStack();\t\t// вывод стека на экран\n \tinline const T &Peek(int ) const;\t\t// n-й элемент от вершины стека\n\tinline int getStackSize() const;\t\t // получить размер стека\n\tinline T *getPtr() const;\t\t// получить указатель на стек\n \tinline int {{doSomething}} const;\t\t// получить номер текущего элемента в стеке\n};","bugs":{"int":{"type": "structures","replace": "T","description": "Дженерик структура не обязана возвращать число"},"doSomething":{"type": "structures","replace": "getTop()","description": "Крайне важно давать осмысленные имена в описании интерфейса!"},"struct":{"type": "structures","replace": "class","description": "Для хранения поведения и состояния используют классы"}}},{"name": "StackMethods","instruction": "Исправьте реализацию методов и применение стека","learning": false,"code": "template <typename T>\nclass Stack\n{\nprivate:\n\tT *stackPtr;\t\t// указатель на стек\n\tconst int size;\t\t// максимальное количество элементов в стеке\n\tint indexOfLast;\t\t// индекс последнего элемента, добавленного в стек\n\n\n// конструктор Стека\ntemplate <typename T>\nStack<T>::Stack(int maxSize) :\n{\n\tsize = maxSize;\n\tstackPtr = new T[size]; // выделить память под стек\n\tindexOfLast= -1;\n}\n\n// функция добавления элемента в стек\ntemplate <typename T>\ninline void Stack<T>::push(const T &value)\n{\n\t// проверяем размер стека\n\tassert(indexOfLast < size); // номер последнего элемента должен быть меньше размера стек\n\tindexOfLast += {{size}};\n\tstackPtr[indexOfLast] = value; // помещаем элемент в стек\n}\n \n// функция удаления элемента из стека\ntemplate <typename T>\ninline T Stack<T>::pop()\n{\n\t// проверяем размер стека\n\tassert(indexOfLast > 0); // номер последнего элемента должен быть больше 0\n\tindexOfLast--;\n\treturn stackPtr[{{indexOfLast}}];\n}\n\nint main()\n{\n\tStack<char> stackSymbol(5);\n\tint i = 0;\n\tchar ch = '0';\n\n\twhile (i++ < 5)\n\t{\n\t\tstackSymbol.push(ch+i); // помещаем элементы в стек\n\t}\n\n\tint magicSum = stackSymbol.pop() - '0' - 1;\n\t{{stackSymbol.pop();}}\n\tmagicSum -= stackSymbol.pop();\n\treturn magicSum;  // должно вернуть 0\n}\n","bugs":{"size":{"type": "structures","replace": "1","description": "При добавление нового элемента, индекс сдвигается на 1"},"indexOfLast":{"type": "structures","replace": "indexOfLast + 1","description": "Следите за тем, какой элемент возвращаете!"},"stackSymbol.pop();":{"type": "structures","replace": "","description": "Элемент стека удаляется из него, при вызове метода pop"}}},{"name":"Array","instruction":"Найдите ошибки при работе с массивами","learning": false,"code": "\n#include <iostream>\n#include <string.h>\nusing namespace std;\nint main ()\n{\n\tint foo[5];\n\t{{foo[5]}} = 400;\n\tfor ( n=4 ; n >=0 ; n-- )\n\t{\n\tresult += foo[n];\n\tcout << foo[n];\n\t}\n\tchar c2[] = 'aaa', c1[] = 'bbb';\n\tc1[2] = a;\n\tc1[1] = a;\n\tc1[0] = a;\n\tif {{(c1 == c2)}}{  // поэлементное сравнение массивов\n\t\treturn 0;\n\t}\n}\n","bugs":{"foo[5]":{"type": "structures","replace": "foo[0]","description": "Элементы массива считаются с 0, поэтому в любом массиве нет элемента с индексом == длине этого массива"},"(c1":{"type": "structures","replace": "strcmp(c1, c2) == 0","description": "Массив символов сравниваются по ссылка, для сравнения по элементам можно использоваться метод strcmp"}}},{"name": "Queue","instruction": "Найдите ошибки при работе с queue", "learning": false,"code":"\n#include <iostream>\n#include <queue>        // подключаем заголовочный файл очереди\n#include <string>       // заголовочный файл для работы со строками типа string\nusing namespace std;\n \nint main()\n{\n\tqueue<string> myQueue;     // создаем пустую очередь типа string\n\t// добавили в очередь несколько элементов типа string\n\tmyQueue.push('No pain');\n\tmyQueue.push('- no gain');\n\n\tcout << 'Количество элементов в очереди: ' << myQueue.size() << endl;\n\tcout << 'Вот они: ' << myQueue.front() << myQueue.back();\n\n\tstring deletedString = {{myQueue.back();}} // удаляем один элемент в очереди\n\tcout << 'Теперь в очереди остался один элемент: ' << {{myQueue[0]}};\n\treturn 0;\n}\n","bugs":{"myQueue[0]":{"type": "structures","replace": "myQueue.front()","description": "Получать элементы очереди можно только через методы front, back, pop"},"myQueue.back();":{"type": "structures","replace": "myQueue.pop();","description": "back возвращает элемент, без удаления его из очереди"}}},{"name": "DFS","instruction": "Найдите ошибки в реализации поиска в ширину","learning":false,"code": "vector <vector<int>> graph;\nvector<bool> used;\nvoid dfs(int node_index)\n{\n\tused[node_index] = true;\n\tfor (const auto &i {{in}} graph[node_index])\n\t{\n\t\tif (!used[i])\n\t\t\t{{return;\n\t\tdfs(i)}};\n\t}\n}","bugs":{"in":{"type": "search","replace": ":","description": "Это не питон!"},"return;\n\t\tdfs(i)":{"type": "search","replace": "dfs(i)","description": "Алгоритм проходит по всем вершинам рекурсивно"}}}]);